<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="# =====================================&#10;# Rock Paper Scissors - 2 Player Game&#10;# =====================================&#10;import cv2&#10;import numpy as np&#10;import mediapipe as mp&#10;from joblib import load&#10;import time&#10;&#10;# =====================================&#10;# 1️⃣ Load trained model and scaler&#10;# =====================================&#10;clf = load(&quot;model/rps_svm_model.joblib&quot;)&#10;scaler = load(&quot;model/rps_scaler.joblib&quot;)&#10;&#10;# =====================================&#10;# 2️⃣ Initialize Mediapipe Hands&#10;# =====================================&#10;mp_hands = mp.solutions.hands&#10;mp_drawing = mp.solutions.drawing_utils&#10;hands = mp_hands.Hands(&#10;    static_image_mode=False,&#10;    max_num_hands=1,&#10;    min_detection_confidence=0.5,&#10;    min_tracking_confidence=0.5&#10;)&#10;&#10;# =====================================&#10;# 3️⃣ Enhanced feature extraction functions&#10;# =====================================&#10;def calculate_distance(p1, p2):&#10;    &quot;&quot;&quot;Calculate Euclidean distance between two points&quot;&quot;&quot;&#10;    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)&#10;&#10;def calculate_angle(p1, p2, p3):&#10;    &quot;&quot;&quot;Calculate angle at p2 formed by p1-p2-p3&quot;&quot;&quot;&#10;    v1 = np.array([p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]])&#10;    v2 = np.array([p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]])&#10;&#10;    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)&#10;    cos_angle = np.clip(cos_angle, -1.0, 1.0)&#10;    return np.arccos(cos_angle)&#10;&#10;def extract_landmarks_from_frame(frame):&#10;    &quot;&quot;&quot;Extract enhanced hand landmarks from a frame region&quot;&quot;&quot;&#10;    image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)&#10;    results = hands.process(image_rgb)&#10;&#10;    if not results.multi_hand_landmarks:&#10;        return None, None&#10;&#10;    hand_landmarks = results.multi_hand_landmarks[0]&#10;&#10;    # Extract all landmarks&#10;    landmarks = []&#10;    for lm in hand_landmarks.landmark:&#10;        landmarks.append([lm.x, lm.y, lm.z])&#10;    landmarks = np.array(landmarks)&#10;&#10;    # Basic features: normalized coordinates relative to wrist&#10;    wrist = landmarks[0]&#10;    normalized_landmarks = landmarks - wrist&#10;    basic_features = normalized_landmarks.flatten()&#10;&#10;    # Enhanced features: distances between key points&#10;    distances = []&#10;    # Fingertip to wrist distances&#10;    fingertips = [4, 8, 12, 16, 20]  # Thumb, Index, Middle, Ring, Pinky tips&#10;    for tip in fingertips:&#10;        distances.append(calculate_distance(landmarks[tip], landmarks[0]))&#10;&#10;    # Fingertip to palm center distances&#10;    palm_center = np.mean(landmarks[[0, 5, 9, 13, 17]], axis=0)&#10;    for tip in fingertips:&#10;        distances.append(calculate_distance(landmarks[tip], palm_center))&#10;&#10;    # Distances between consecutive fingertips&#10;    for i in range(len(fingertips) - 1):&#10;        distances.append(calculate_distance(landmarks[fingertips[i]], landmarks[fingertips[i+1]]))&#10;&#10;    # Finger angles (at MCP joints)&#10;    angles = []&#10;    finger_connections = [&#10;        [2, 3, 4],    # Thumb&#10;        [5, 6, 7],    # Index&#10;        [9, 10, 11],  # Middle&#10;        [13, 14, 15], # Ring&#10;        [17, 18, 19]  # Pinky&#10;    ]&#10;&#10;    for conn in finger_connections:&#10;        angles.append(calculate_angle(landmarks[conn[0]], landmarks[conn[1]], landmarks[conn[2]]))&#10;&#10;    # Palm spread (distance between thumb base and pinky base)&#10;    palm_spread = calculate_distance(landmarks[2], landmarks[17])&#10;&#10;    # Combine all features&#10;    enhanced_features = np.concatenate([&#10;        basic_features,&#10;        np.array(distances),&#10;        np.array(angles),&#10;        [palm_spread]&#10;    ])&#10;&#10;    return enhanced_features, hand_landmarks&#10;&#10;# =====================================&#10;# 4️⃣ Predict gesture&#10;# =====================================&#10;def predict_gesture(features):&#10;    &quot;&quot;&quot;Predict rock, paper, or scissors from features&quot;&quot;&quot;&#10;    if features is None:&#10;        return None&#10;&#10;    features_scaled = scaler.transform([features])&#10;    prediction = clf.predict(features_scaled)[0]&#10;&#10;    labels = {0: &quot;Rock&quot;, 1: &quot;Paper&quot;, 2: &quot;Scissors&quot;}&#10;    return labels[prediction]&#10;&#10;# =====================================&#10;# 5️⃣ Determine winner&#10;# =====================================&#10;def determine_winner(player1_gesture, player2_gesture):&#10;    &quot;&quot;&quot;Determine the winner of the game&quot;&quot;&quot;&#10;    if player1_gesture is None or player2_gesture is None:&#10;        return &quot;Waiting...&quot;&#10;&#10;    if player1_gesture == player2_gesture:&#10;        return &quot;Draw!&quot;&#10;&#10;    win_conditions = {&#10;        (&quot;Rock&quot;, &quot;Scissors&quot;): &quot;Player 1 Wins!&quot;,&#10;        (&quot;Scissors&quot;, &quot;Paper&quot;): &quot;Player 1 Wins!&quot;,&#10;        (&quot;Paper&quot;, &quot;Rock&quot;): &quot;Player 1 Wins!&quot;,&#10;        (&quot;Scissors&quot;, &quot;Rock&quot;): &quot;Player 2 Wins!&quot;,&#10;        (&quot;Paper&quot;, &quot;Scissors&quot;): &quot;Player 2 Wins!&quot;,&#10;        (&quot;Rock&quot;, &quot;Paper&quot;): &quot;Player 2 Wins!&quot;&#10;    }&#10;&#10;    return win_conditions.get((player1_gesture, player2_gesture), &quot;Waiting...&quot;)&#10;&#10;# =====================================&#10;# 6️⃣ Main game loop&#10;# =====================================&#10;def main():&#10;    cap = cv2.VideoCapture(0)&#10;    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)&#10;    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)&#10;&#10;    # Game state&#10;    game_mode = &quot;play&quot;  # &quot;play&quot; or &quot;countdown&quot;&#10;    countdown_start = None&#10;    countdown_duration = 3&#10;    player1_final = None&#10;    player2_final = None&#10;    result = &quot;&quot;&#10;    result_time = None&#10;&#10;    print(&quot; Rock Paper Scissors Game Started!&quot;)&#10;    print(&quot; Controls:&quot;)&#10;    print(&quot;   SPACE - Start countdown and capture gestures&quot;)&#10;    print(&quot;   R - Reset game&quot;)&#10;    print(&quot;   Q - Quit&quot;)&#10;    print(&quot;\n Position your hands:&quot;)&#10;    print(&quot;   Player 1: Left side of screen&quot;)&#10;    print(&quot;   Player 2: Right side of screen&quot;)&#10;&#10;    while True:&#10;        ret, frame = cap.read()&#10;        if not ret:&#10;            break&#10;&#10;        frame = cv2.flip(frame, 1)  # Mirror the frame&#10;        height, width = frame.shape[:2]&#10;        mid_width = width // 2&#10;&#10;        # Split frame into two halves&#10;        frame_left = frame[:, :mid_width].copy()&#10;        frame_right = frame[:, mid_width:].copy()&#10;&#10;        # Process both players&#10;        features_p1, landmarks_p1 = extract_landmarks_from_frame(frame_left)&#10;        features_p2, landmarks_p2 = extract_landmarks_from_frame(frame_right)&#10;&#10;        # Draw hand landmarks&#10;        if landmarks_p1:&#10;            mp_drawing.draw_landmarks(&#10;                frame_left, landmarks_p1, mp_hands.HAND_CONNECTIONS,&#10;                mp_drawing.DrawingSpec(color=(0, 255, 0), thickness=2, circle_radius=2),&#10;                mp_drawing.DrawingSpec(color=(0, 255, 255), thickness=2)&#10;            )&#10;&#10;        if landmarks_p2:&#10;            mp_drawing.draw_landmarks(&#10;                frame_right, landmarks_p2, mp_hands.HAND_CONNECTIONS,&#10;                mp_drawing.DrawingSpec(color=(0, 255, 0), thickness=2, circle_radius=2),&#10;                mp_drawing.DrawingSpec(color=(0, 255, 255), thickness=2)&#10;            )&#10;&#10;        # Game logic&#10;        if game_mode == &quot;play&quot;:&#10;            # Real-time prediction&#10;            gesture_p1 = predict_gesture(features_p1) if features_p1 is not None else &quot;No hand&quot;&#10;            gesture_p2 = predict_gesture(features_p2) if features_p2 is not None else &quot;No hand&quot;&#10;&#10;            # Display gestures&#10;            cv2.putText(frame_left, f&quot;Player 1&quot;, (10, 40),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_left, f&quot;{gesture_p1}&quot;, (10, 80),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;            cv2.putText(frame_right, f&quot;Player 2&quot;, (10, 40),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_right, f&quot;{gesture_p2}&quot;, (10, 80),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;        elif game_mode == &quot;countdown&quot;:&#10;            # Countdown mode&#10;            elapsed = time.time() - countdown_start&#10;            remaining = countdown_duration - elapsed&#10;&#10;            if remaining &gt; 0:&#10;                countdown_text = str(int(remaining) + 1)&#10;&#10;                # Display countdown on both sides&#10;                cv2.putText(frame_left, countdown_text, (mid_width//2 - 50, height//2),&#10;                           cv2.FONT_HERSHEY_SIMPLEX, 4, (0, 255, 255), 8)&#10;                cv2.putText(frame_right, countdown_text, (mid_width//2 - 50, height//2),&#10;                           cv2.FONT_HERSHEY_SIMPLEX, 4, (0, 255, 255), 8)&#10;            else:&#10;                # Capture final gestures&#10;                player1_final = predict_gesture(features_p1) if features_p1 is not None else None&#10;                player2_final = predict_gesture(features_p2) if features_p2 is not None else None&#10;                result = determine_winner(player1_final, player2_final)&#10;                result_time = time.time()&#10;                game_mode = &quot;result&quot;&#10;&#10;        elif game_mode == &quot;result&quot;:&#10;            # Display results&#10;            cv2.putText(frame_left, f&quot;Player 1&quot;, (10, 40),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_left, f&quot;{player1_final if player1_final else 'No hand'}&quot;,&#10;                       (10, 80), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;            cv2.putText(frame_right, f&quot;Player 2&quot;, (10, 40),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_right, f&quot;{player2_final if player2_final else 'No hand'}&quot;,&#10;                       (10, 80), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;            # Show result for 3 seconds, then return to play mode&#10;            if time.time() - result_time &gt; 3:&#10;                game_mode = &quot;play&quot;&#10;                player1_final = None&#10;                player2_final = None&#10;                result = &quot;&quot;&#10;&#10;        # Combine frames&#10;        combined_frame = np.hstack([frame_left, frame_right])&#10;&#10;        # Draw center line&#10;        cv2.line(combined_frame, (mid_width, 0), (mid_width, height), (255, 255, 255), 2)&#10;&#10;        # Display result in center&#10;        if result:&#10;            text_size = cv2.getTextSize(result, cv2.FONT_HERSHEY_SIMPLEX, 2, 3)[0]&#10;            text_x = (width - text_size[0]) // 2&#10;            text_y = height - 50&#10;&#10;            # Background rectangle&#10;            cv2.rectangle(combined_frame,&#10;                         (text_x - 10, text_y - text_size[1] - 10),&#10;                         (text_x + text_size[0] + 10, text_y + 10),&#10;                         (0, 0, 0), -1)&#10;&#10;            # Result text&#10;            color = (0, 255, 0) if &quot;Draw&quot; in result else (0, 255, 255) if &quot;Player 1&quot; in result else (0, 165, 255)&#10;            cv2.putText(combined_frame, result, (text_x, text_y),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 2, color, 3)&#10;&#10;        # Display instructions&#10;        cv2.putText(combined_frame, &quot;SPACE: Start | R: Reset | Q: Quit&quot;,&#10;                   (10, height - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)&#10;&#10;        cv2.imshow(&quot;Rock Paper Scissors - 2 Players&quot;, combined_frame)&#10;&#10;        # Handle keyboard input&#10;        key = cv2.waitKey(1) &amp; 0xFF&#10;&#10;        if key == ord('q'):&#10;            break&#10;        elif key == ord(' ') and game_mode == &quot;play&quot;:&#10;            # Start countdown&#10;            game_mode = &quot;countdown&quot;&#10;            countdown_start = time.time()&#10;            result = &quot;&quot;&#10;        elif key == ord('r'):&#10;            # Reset game&#10;            game_mode = &quot;play&quot;&#10;            player1_final = None&#10;            player2_final = None&#10;            result = &quot;&quot;&#10;&#10;    cap.release()&#10;    cv2.destroyAllWindows()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="# =====================================&#10;# Rock Paper Scissors - 2 Player Game&#10;# =====================================&#10;import cv2&#10;import numpy as np&#10;import mediapipe as mp&#10;from joblib import load&#10;import time&#10;&#10;# =====================================&#10;# 1️⃣ Load trained model and scaler&#10;# =====================================&#10;clf = load(&quot;model/rps_svm_model.joblib&quot;)&#10;scaler = load(&quot;model/rps_scaler.joblib&quot;)&#10;&#10;# =====================================&#10;# 2️⃣ Initialize Mediapipe Hands&#10;# =====================================&#10;mp_hands = mp.solutions.hands&#10;mp_drawing = mp.solutions.drawing_utils&#10;hands = mp_hands.Hands(&#10;    static_image_mode=False,&#10;    max_num_hands=1,&#10;    min_detection_confidence=0.5,&#10;    min_tracking_confidence=0.5&#10;)&#10;&#10;# =====================================&#10;# 3️⃣ Enhanced feature extraction functions&#10;# =====================================&#10;def calculate_distance(p1, p2):&#10;    &quot;&quot;&quot;Calculate Euclidean distance between two points&quot;&quot;&quot;&#10;    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)&#10;&#10;def calculate_angle(p1, p2, p3):&#10;    &quot;&quot;&quot;Calculate angle at p2 formed by p1-p2-p3&quot;&quot;&quot;&#10;    v1 = np.array([p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]])&#10;    v2 = np.array([p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]])&#10;&#10;    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)&#10;    cos_angle = np.clip(cos_angle, -1.0, 1.0)&#10;    return np.arccos(cos_angle)&#10;&#10;def normalize_hand_orientation(landmarks):&#10;    &quot;&quot;&quot;&#10;    Normalize hand orientation to match training data (hand pointing up)&#10;    This rotates the hand so that wrist-to-middle-finger direction points upward&#10;    &quot;&quot;&quot;&#10;    # Key points: wrist (0) and middle finger MCP (9)&#10;    wrist = landmarks[0]&#10;    middle_mcp = landmarks[9]&#10;&#10;    # Calculate current hand direction vector (wrist to middle finger base)&#10;    hand_vector = middle_mcp - wrist&#10;    hand_vector_2d = hand_vector[:2]  # Use only x, y for rotation&#10;&#10;    # Calculate angle to rotate hand to point upward (negative y direction)&#10;    # In image coordinates, up is negative y&#10;    current_angle = np.arctan2(hand_vector_2d[0], -hand_vector_2d[1])&#10;&#10;    # Create 2D rotation matrix&#10;    cos_angle = np.cos(-current_angle)&#10;    sin_angle = np.sin(-current_angle)&#10;    rotation_matrix_2d = np.array([&#10;        [cos_angle, -sin_angle],&#10;        [sin_angle, cos_angle]&#10;    ])&#10;&#10;    # Rotate all landmarks (only x, y coordinates)&#10;    rotated_landmarks = landmarks.copy()&#10;    for i in range(len(landmarks)):&#10;        # Translate to origin (relative to wrist)&#10;        point_2d = landmarks[i][:2] - wrist[:2]&#10;        # Rotate&#10;        rotated_point_2d = rotation_matrix_2d @ point_2d&#10;        # Translate back&#10;        rotated_landmarks[i][:2] = rotated_point_2d + wrist[:2]&#10;        # Keep z coordinate unchanged&#10;        rotated_landmarks[i][2] = landmarks[i][2]&#10;&#10;    return rotated_landmarks&#10;&#10;def draw_normalized_hand(frame, landmarks, position=&quot;top-left&quot;):&#10;    &quot;&quot;&quot;&#10;    Draw normalized hand visualization in a small window&#10;    position: &quot;top-left&quot; or &quot;top-right&quot;&#10;    &quot;&quot;&quot;&#10;    # Create small visualization window&#10;    viz_size = 200&#10;    viz_img = np.zeros((viz_size, viz_size, 3), dtype=np.uint8)&#10;    &#10;    # Scale and center the landmarks for visualization&#10;    landmarks_2d = landmarks[:, :2].copy()&#10;    &#10;    # Normalize to fit in visualization window&#10;    min_x, min_y = landmarks_2d.min(axis=0)&#10;    max_x, max_y = landmarks_2d.max(axis=0)&#10;    &#10;    # Scale to fit 80% of window&#10;    scale = 0.8 * viz_size / max(max_x - min_x, max_y - min_y)&#10;    landmarks_2d = (landmarks_2d - [min_x, min_y]) * scale&#10;    &#10;    # Center in window&#10;    offset = [(viz_size - (max_x - min_x) * scale) / 2,&#10;              (viz_size - (max_y - min_y) * scale) / 2]&#10;    landmarks_2d = landmarks_2d + offset&#10;    &#10;    # Draw hand connections&#10;    connections = [&#10;        # Thumb&#10;        (0, 1), (1, 2), (2, 3), (3, 4),&#10;        # Index&#10;        (0, 5), (5, 6), (6, 7), (7, 8),&#10;        # Middle&#10;        (0, 9), (9, 10), (10, 11), (11, 12),&#10;        # Ring&#10;        (0, 13), (13, 14), (14, 15), (15, 16),&#10;        # Pinky&#10;        (0, 17), (17, 18), (18, 19), (19, 20),&#10;        # Palm&#10;        (5, 9), (9, 13), (13, 17)&#10;    ]&#10;    &#10;    for connection in connections:&#10;        pt1 = tuple(landmarks_2d[connection[0]].astype(int))&#10;        pt2 = tuple(landmarks_2d[connection[1]].astype(int))&#10;        cv2.line(viz_img, pt1, pt2, (0, 255, 255), 2)&#10;    &#10;    # Draw landmarks&#10;    for point in landmarks_2d:&#10;        cv2.circle(viz_img, tuple(point.astype(int)), 3, (0, 255, 0), -1)&#10;    &#10;    # Add title&#10;    cv2.putText(viz_img, &quot;Normalized&quot;, (5, 20),&#10;                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)&#10;    &#10;    # Overlay on main frame&#10;    h, w = frame.shape[:2]&#10;    margin = 10&#10;    &#10;    if position == &quot;top-left&quot;:&#10;        x_offset, y_offset = margin, margin&#10;    else:  # top-right&#10;        x_offset, y_offset = w - viz_size - margin, margin&#10;    &#10;    # Create border&#10;    cv2.rectangle(frame, (x_offset-2, y_offset-2), &#10;                  (x_offset+viz_size+2, y_offset+viz_size+2), &#10;                  (255, 255, 255), 2)&#10;    &#10;    # Overlay visualization&#10;    frame[y_offset:y_offset+viz_size, x_offset:x_offset+viz_size] = viz_img&#10;    &#10;    return frame&#10;&#10;def extract_landmarks_from_frame(frame):&#10;    &quot;&quot;&quot;Extract enhanced hand landmarks from a frame region&quot;&quot;&quot;&#10;    image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)&#10;    results = hands.process(image_rgb)&#10;&#10;    if not results.multi_hand_landmarks:&#10;        return None, None, None&#10;&#10;    hand_landmarks = results.multi_hand_landmarks[0]&#10;&#10;    # Extract all landmarks&#10;    landmarks = []&#10;    for lm in hand_landmarks.landmark:&#10;        landmarks.append([lm.x, lm.y, lm.z])&#10;    landmarks = np.array(landmarks)&#10;    &#10;    # Store original landmarks for drawing&#10;    original_landmarks = landmarks.copy()&#10;&#10;    # **PREPROCESSING: Normalize hand orientation (rotate to point upward)**&#10;    landmarks = normalize_hand_orientation(landmarks)&#10;&#10;    # Basic features: normalized coordinates relative to wrist&#10;    wrist = landmarks[0]&#10;    normalized_landmarks = landmarks - wrist&#10;    basic_features = normalized_landmarks.flatten()&#10;&#10;    # Enhanced features: distances between key points&#10;    distances = []&#10;    # Fingertip to wrist distances&#10;    fingertips = [4, 8, 12, 16, 20]  # Thumb, Index, Middle, Ring, Pinky tips&#10;    for tip in fingertips:&#10;        distances.append(calculate_distance(landmarks[tip], landmarks[0]))&#10;&#10;    # Fingertip to palm center distances&#10;    palm_center = np.mean(landmarks[[0, 5, 9, 13, 17]], axis=0)&#10;    for tip in fingertips:&#10;        distances.append(calculate_distance(landmarks[tip], palm_center))&#10;&#10;    # Distances between consecutive fingertips&#10;    for i in range(len(fingertips) - 1):&#10;        distances.append(calculate_distance(landmarks[fingertips[i]], landmarks[fingertips[i+1]]))&#10;&#10;    # Finger angles (at MCP joints)&#10;    angles = []&#10;    finger_connections = [&#10;        [2, 3, 4],    # Thumb&#10;        [5, 6, 7],    # Index&#10;        [9, 10, 11],  # Middle&#10;        [13, 14, 15], # Ring&#10;        [17, 18, 19]  # Pinky&#10;    ]&#10;&#10;    for conn in finger_connections:&#10;        angles.append(calculate_angle(landmarks[conn[0]], landmarks[conn[1]], landmarks[conn[2]]))&#10;&#10;    # Palm spread (distance between thumb base and pinky base)&#10;    palm_spread = calculate_distance(landmarks[2], landmarks[17])&#10;&#10;    # Combine all features&#10;    enhanced_features = np.concatenate([&#10;        basic_features,&#10;        np.array(distances),&#10;        np.array(angles),&#10;        [palm_spread]&#10;    ])&#10;&#10;    return enhanced_features, hand_landmarks, landmarks&#10;&#10;# =====================================&#10;# 4️⃣ Predict gesture&#10;# =====================================&#10;def predict_gesture(features):&#10;    &quot;&quot;&quot;Predict rock, paper, or scissors from features&quot;&quot;&quot;&#10;    if features is None:&#10;        return None&#10;&#10;    features_scaled = scaler.transform([features])&#10;    prediction = clf.predict(features_scaled)[0]&#10;&#10;    labels = {0: &quot;Rock&quot;, 1: &quot;Paper&quot;, 2: &quot;Scissors&quot;}&#10;    return labels[prediction]&#10;&#10;# =====================================&#10;# 5️⃣ Determine winner&#10;# =====================================&#10;def determine_winner(player1_gesture, player2_gesture):&#10;    &quot;&quot;&quot;Determine the winner of the game&quot;&quot;&quot;&#10;    if player1_gesture is None or player2_gesture is None:&#10;        return None&#10;    &#10;    if player1_gesture == player2_gesture:&#10;        return &quot;draw&quot;&#10;    &#10;    win_conditions = {&#10;        (&quot;Rock&quot;, &quot;Scissors&quot;): &quot;p1&quot;,&#10;        (&quot;Scissors&quot;, &quot;Paper&quot;): &quot;p1&quot;,&#10;        (&quot;Paper&quot;, &quot;Rock&quot;): &quot;p1&quot;,&#10;        (&quot;Scissors&quot;, &quot;Rock&quot;): &quot;p2&quot;,&#10;        (&quot;Paper&quot;, &quot;Scissors&quot;): &quot;p2&quot;,&#10;        (&quot;Rock&quot;, &quot;Paper&quot;): &quot;p2&quot;&#10;    }&#10;    &#10;    return win_conditions.get((player1_gesture, player2_gesture), None)&#10;&#10;# =====================================&#10;# 6️⃣ Main game loop&#10;# =====================================&#10;def main():&#10;    cap = cv2.VideoCapture(0)&#10;    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)&#10;    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)&#10;&#10;    # Game state&#10;    game_mode = &quot;play&quot;  # &quot;play&quot; or &quot;countdown&quot;&#10;    countdown_start = None&#10;    countdown_duration = 3&#10;    player1_final = None&#10;    player2_final = None&#10;    result = &quot;&quot;&#10;    result_time = None&#10;    &#10;    # Score tracking&#10;    player1_score = 0&#10;    player2_score = 0&#10;    draws = 0&#10;&#10;    print(&quot; Rock Paper Scissors Game Started!&quot;)&#10;    print(&quot; Controls:&quot;)&#10;    print(&quot;   SPACE - Start countdown and capture gestures&quot;)&#10;    print(&quot;   R - Reset game and scores&quot;)&#10;    print(&quot;   Q - Quit&quot;)&#10;    print(&quot;\n Position your hands:&quot;)&#10;    print(&quot;   Player 1: Left side of screen&quot;)&#10;    print(&quot;   Player 2: Right side of screen&quot;)&#10;&#10;    while True:&#10;        ret, frame = cap.read()&#10;        if not ret:&#10;            break&#10;&#10;        frame = cv2.flip(frame, 1)  # Mirror the frame&#10;        height, width = frame.shape[:2]&#10;        mid_width = width // 2&#10;&#10;        # Split frame into two halves&#10;        frame_left = frame[:, :mid_width].copy()&#10;        frame_right = frame[:, mid_width:].copy()&#10;&#10;        # Process both players&#10;        features_p1, landmarks_p1, normalized_p1 = extract_landmarks_from_frame(frame_left)&#10;        features_p2, landmarks_p2, normalized_p2 = extract_landmarks_from_frame(frame_right)&#10;&#10;        # Draw hand landmarks (original)&#10;        if landmarks_p1:&#10;            mp_drawing.draw_landmarks(&#10;                frame_left, landmarks_p1, mp_hands.HAND_CONNECTIONS,&#10;                mp_drawing.DrawingSpec(color=(0, 255, 0), thickness=2, circle_radius=2),&#10;                mp_drawing.DrawingSpec(color=(0, 255, 255), thickness=2)&#10;            )&#10;            # Draw normalized hand visualization&#10;            if normalized_p1 is not None:&#10;                frame_left = draw_normalized_hand(frame_left, normalized_p1, &quot;top-left&quot;)&#10;&#10;        if landmarks_p2:&#10;            mp_drawing.draw_landmarks(&#10;                frame_right, landmarks_p2, mp_hands.HAND_CONNECTIONS,&#10;                mp_drawing.DrawingSpec(color=(0, 255, 0), thickness=2, circle_radius=2),&#10;                mp_drawing.DrawingSpec(color=(0, 255, 255), thickness=2)&#10;            )&#10;            # Draw normalized hand visualization&#10;            if normalized_p2 is not None:&#10;                frame_right = draw_normalized_hand(frame_right, normalized_p2, &quot;top-right&quot;)&#10;&#10;        # Game logic&#10;        if game_mode == &quot;play&quot;:&#10;            # Real-time prediction&#10;            gesture_p1 = predict_gesture(features_p1) if features_p1 is not None else &quot;No hand&quot;&#10;            gesture_p2 = predict_gesture(features_p2) if features_p2 is not None else &quot;No hand&quot;&#10;&#10;            # Display gestures&#10;            cv2.putText(frame_left, f&quot;Player 1&quot;, (10, 250),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_left, f&quot;{gesture_p1}&quot;, (10, 290),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;            cv2.putText(frame_right, f&quot;Player 2&quot;, (10, 250),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_right, f&quot;{gesture_p2}&quot;, (10, 290),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;        elif game_mode == &quot;countdown&quot;:&#10;            # Countdown mode&#10;            elapsed = time.time() - countdown_start&#10;            remaining = countdown_duration - elapsed&#10;&#10;            if remaining &gt; 0:&#10;                countdown_text = str(int(remaining) + 1)&#10;&#10;                # Display countdown on both sides&#10;                cv2.putText(frame_left, countdown_text, (mid_width//2 - 50, height//2),&#10;                           cv2.FONT_HERSHEY_SIMPLEX, 4, (0, 255, 255), 8)&#10;                cv2.putText(frame_right, countdown_text, (mid_width//2 - 50, height//2),&#10;                           cv2.FONT_HERSHEY_SIMPLEX, 4, (0, 255, 255), 8)&#10;            else:&#10;                # Capture final gestures&#10;                player1_final = predict_gesture(features_p1) if features_p1 is not None else None&#10;                player2_final = predict_gesture(features_p2) if features_p2 is not None else None&#10;                winner = determine_winner(player1_final, player2_final)&#10;                &#10;                # Update scores&#10;                if winner == &quot;p1&quot;:&#10;                    player1_score += 1&#10;                    result = &quot;Player 1 Wins!&quot;&#10;                elif winner == &quot;p2&quot;:&#10;                    player2_score += 1&#10;                    result = &quot;Player 2 Wins!&quot;&#10;                elif winner == &quot;draw&quot;:&#10;                    draws += 1&#10;                    result = &quot;Draw!&quot;&#10;                else:&#10;                    result = &quot;No hands detected!&quot;&#10;                &#10;                result_time = time.time()&#10;                game_mode = &quot;result&quot;&#10;&#10;        elif game_mode == &quot;result&quot;:&#10;            # Display results&#10;            cv2.putText(frame_left, f&quot;Player 1&quot;, (10, 250),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_left, f&quot;{player1_final if player1_final else 'No hand'}&quot;,&#10;                       (10, 290), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;            cv2.putText(frame_right, f&quot;Player 2&quot;, (10, 250),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)&#10;            cv2.putText(frame_right, f&quot;{player2_final if player2_final else 'No hand'}&quot;,&#10;                       (10, 290), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)&#10;&#10;            # Show result for 3 seconds, then return to play mode&#10;            if time.time() - result_time &gt; 3:&#10;                game_mode = &quot;play&quot;&#10;                player1_final = None&#10;                player2_final = None&#10;                result = &quot;&quot;&#10;&#10;        # Combine frames&#10;        combined_frame = np.hstack([frame_left, frame_right])&#10;&#10;        # Draw center line&#10;        cv2.line(combined_frame, (mid_width, 0), (mid_width, height), (255, 255, 255), 2)&#10;&#10;        # Display scores at the top center&#10;        score_text = f&quot;P1: {player1_score}  |  Draws: {draws}  |  P2: {player2_score}&quot;&#10;        text_size = cv2.getTextSize(score_text, cv2.FONT_HERSHEY_SIMPLEX, 1.2, 3)[0]&#10;        score_x = (width - text_size[0]) // 2&#10;        score_y = 50&#10;        &#10;        # Background for score&#10;        cv2.rectangle(combined_frame,&#10;                     (score_x - 10, score_y - text_size[1] - 10),&#10;                     (score_x + text_size[0] + 10, score_y + 10),&#10;                     (0, 0, 0), -1)&#10;        &#10;        # Score text&#10;        cv2.putText(combined_frame, score_text, (score_x, score_y),&#10;                   cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)&#10;        &#10;        # Highlight who's winning&#10;        if player1_score &gt; player2_score:&#10;            cv2.putText(combined_frame, &quot;WINNING!&quot;, (50, 100),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)&#10;        elif player2_score &gt; player1_score:&#10;            cv2.putText(combined_frame, &quot;WINNING!&quot;, (width - 250, 100),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)&#10;&#10;        # Display result in center&#10;        if result:&#10;            text_size = cv2.getTextSize(result, cv2.FONT_HERSHEY_SIMPLEX, 2, 3)[0]&#10;            text_x = (width - text_size[0]) // 2&#10;            text_y = height - 50&#10;&#10;            # Background rectangle&#10;            cv2.rectangle(combined_frame,&#10;                         (text_x - 10, text_y - text_size[1] - 10),&#10;                         (text_x + text_size[0] + 10, text_y + 10),&#10;                         (0, 0, 0), -1)&#10;&#10;            # Result text&#10;            if &quot;Player 1&quot; in result:&#10;                color = (0, 255, 255)&#10;            elif &quot;Player 2&quot; in result:&#10;                color = (0, 165, 255)&#10;            else:&#10;                color = (0, 255, 0)&#10;            &#10;            cv2.putText(combined_frame, result, (text_x, text_y),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 2, color, 3)&#10;&#10;        # Display instructions&#10;        cv2.putText(combined_frame, &quot;SPACE: Start | R: Reset Scores | Q: Quit&quot;,&#10;                   (10, height - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)&#10;&#10;        cv2.imshow(&quot;Rock Paper Scissors - 2 Players&quot;, combined_frame)&#10;&#10;        # Handle keyboard input&#10;        key = cv2.waitKey(1) &amp; 0xFF&#10;&#10;        if key == ord('q'):&#10;            break&#10;        elif key == ord(' ') and game_mode == &quot;play&quot;:&#10;            # Start countdown&#10;            game_mode = &quot;countdown&quot;&#10;            countdown_start = time.time()&#10;            result = &quot;&quot;&#10;        elif key == ord('r'):&#10;            # Reset game and scores&#10;            game_mode = &quot;play&quot;&#10;            player1_final = None&#10;            player2_final = None&#10;            result = &quot;&quot;&#10;            player1_score = 0&#10;            player2_score = 0&#10;            draws = 0&#10;            print(&quot;\n Scores reset!&quot;)&#10;&#10;    cap.release()&#10;    cv2.destroyAllWindows()&#10;    &#10;    # Print final scores&#10;    print(&quot;\n&quot; + &quot;=&quot;*50)&#10;    print(&quot; FINAL SCORES &quot;)&#10;    print(&quot;=&quot;*50)&#10;    print(f&quot;Player 1: {player1_score}&quot;)&#10;    print(f&quot;Player 2: {player2_score}&quot;)&#10;    print(f&quot;Draws: {draws}&quot;)&#10;    if player1_score &gt; player2_score:&#10;        print(&quot;\n Player 1 is the WINNER! &quot;)&#10;    elif player2_score &gt; player1_score:&#10;        print(&quot;\n Player 2 is the WINNER! &quot;)&#10;    else:&#10;        print(&quot;\n It's a TIE! &quot;)&#10;    print(&quot;=&quot;*50)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>